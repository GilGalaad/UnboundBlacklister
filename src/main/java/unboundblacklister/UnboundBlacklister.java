package unboundblacklister;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static java.nio.charset.StandardCharsets.UTF_8;

public class UnboundBlacklister {

    private static final String HOST_FILE_URL = "https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts";

    private static final String HOSTNAME_REGEX = "^0\\.0\\.0\\.0\\s+(?<hostname>([a-zA-Z0-9_-]+\\.)+[a-zA-Z0-9_-]{2,})(\\s+#.*)?$";
    private static final Pattern HOSTNAME_PATTERN = Pattern.compile(HOSTNAME_REGEX);

    public static void main(String[] args) {
        log("Process start at: " + DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss").format(LocalDateTime.now()));
        try {
            // determining file location
            Path jarPath = getJarLocation();

            // optional whitelist
            Path whiteListPath = jarPath.resolve("whitelist.conf");
            HashSet<String> whiteList;
            if (Files.exists(whiteListPath) && Files.isRegularFile(whiteListPath) && Files.isReadable(whiteListPath)) {
                log("Loading whitelisted domains");
                whiteList = loadDomainsFromFile(whiteListPath);
                log("Loaded " + whiteList.size() + " whitelisted unique domains");
            } else {
                log("Optional whitelist file not found");
                whiteList = new HashSet<>();
            }

            // fetching source host file
            log("Fetching remote host file: " + HOST_FILE_URL);
            String hostFileContent = fetchHostFile();
            HashSet<String> blacklist = parseHostFile(hostFileContent, whiteList);
            log("Loaded " + blacklist.size() + " blacklisted unique domains");

            // ordering and printing
            ArrayList<String> orderedBlacklist = new ArrayList<>(blacklist);
            Collections.sort(orderedBlacklist);
            for (String hostname : orderedBlacklist) {
                print("local-data: \"" + hostname + ". A 0.0.0.0\"");
            }
        } catch (Exception ex) {
            log(ex.getMessage());
            System.exit(1);
        }
    }

    private static void log(String msg) {
        System.out.println("# " + msg);
    }

    private static void print(String msg) {
        System.out.println(msg);
    }

    private static Path getJarLocation() {
        try {
            Path ret = Paths.get(UnboundBlacklister.class.getProtectionDomain().getCodeSource().getLocation().toURI());
            if (Files.isRegularFile(ret)) {
                return ret.getParent();
            } else if (ret.getFileName().toString().equalsIgnoreCase("classes") && ret.getParent() != null && ret.getParent().getFileName().toString().equalsIgnoreCase("target")) {
                return ret.getParent().getParent();
            } else {
                return ret;
            }
        } catch (URISyntaxException ex) {
            // should never happen because URL is generated by JDK itself
            throw new RuntimeException(ex.getClass().getSimpleName() + " while getting jar location: " + ex.getMessage(), ex);
        }
    }

    private static HashSet<String> loadDomainsFromFile(Path path) {
        try {
            List<String> lines = Files.readAllLines(path, UTF_8);
            return lines.stream().map(String::trim).map(String::toLowerCase).filter(i -> !i.isBlank() && !i.startsWith("#")).collect(Collectors.toCollection(HashSet::new));
        } catch (IOException ex) {
            throw new RuntimeException(ex.getClass().getSimpleName() + " while parsing whitelist file: " + ex.getMessage(), ex);
        }
    }

    private static String fetchHostFile() {
        try {
            URL url = new URL(HOST_FILE_URL);
            try (InputStream is = url.openStream()) {
                return new String(is.readAllBytes(), UTF_8);
            }
        } catch (IOException ex) {
            throw new RuntimeException(ex.getClass().getSimpleName() + " while fetching host file from URL: " + ex.getMessage(), ex);
        }
    }

    private static HashSet<String> parseHostFile(String hostFileContent, HashSet<String> whitelist) {
        try (BufferedReader br = new BufferedReader(new StringReader(hostFileContent))) {
            HashSet<String> ret = new HashSet<>();
            String line;
            while ((line = br.readLine()) != null) {
                line = line.trim().toLowerCase();
                if (line.isBlank() || line.startsWith("#")
                        || line.startsWith("0.0.0.0 0.0.0.0") || line.startsWith("127.0.0.1") || line.startsWith("255.255.255.255")
                        || line.startsWith("::1") || (line.startsWith("f") && line.contains(":"))) {
                    continue;
                }
                Matcher m = HOSTNAME_PATTERN.matcher(line);
                if (!m.matches()) {
                    log("Invalid host: " + line);
                    continue;
                }
                String hostname = m.group("hostname");
                if (!isWhitelisted(hostname, whitelist)) {
                    ret.add(hostname);
                }
            }
            return ret;
        } catch (IOException ex) {
            throw new RuntimeException(ex.getClass().getSimpleName() + " while parsing host file: " + ex.getMessage(), ex);
        }
    }

    private static boolean isWhitelisted(String hostname, HashSet<String> whitelist) {
        for (var whitelisted : whitelist) {
            if (hostname.equals(whitelisted) || hostname.endsWith("." + whitelisted)) {
                return true;
            }
        }
        return false;
    }

}
